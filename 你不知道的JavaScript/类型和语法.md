## 类型

ECMAScript规范中是这样说的：

> ECMAScript语言中所有的值都有一个对应的语言类型。ECMAScript语言类型包括`Undefined`、`Null`、`Boolean`、`String`、`Number`和`Object`。

在JavaScript中，类型与强类型语言中的类型有些不太一样，这里面的类型是值的内部特征，定义了值的行为，使其区别于其他值。

### 内置类型

JavaScript有7中内置类型，除了对象外，其他6种又被称为基本类型：

* 空值：null
* 未定义：undefined
* 数字：number
* 字符串：string
* 对象：object
* 布尔值：boolean
* 符号：symbol（ES6)

针对基本类型的判断，可以使用`typeof`运算符，这个运算符可以获得某个变量对应的类型字符串，但是针对`null`，需要再加一层判断，因为其`typeof null === 'object'`。而数组和函数都是对象的一个子类型，函数有其自身特殊的类型字符串。

### 值和类型

JavaScript中的变量是没有类型的，只有值才有类型。变量可以随时持有任何类型的值。而针对变量执行`typeof`操作的时候，得到的结果并不是变量的类型，而是变量对应的值的类型。

#### `undefined`和undeclared

变量在未持有值的时候为`undefined`，这时候`typeof`返回`"undefined"`。`undefined`并不等同于undeclared未声明。已经在作用域中声明，但是还未赋值的变量，是`undefined`的，相反，还没有在作用域中声明的变量，是undeclared的。但是对于这两种变量的`typeof`操作都会返回`undefined`

`typeof`运算符可以很好地用于检测变量是否存在：

```
// 这样的情况，如果DEBUG没有声明，则会抛出错误
if (DEBUG) {
  console.log( "Debugging is starting" )
}
// 这样是安全的
if (typeof DEBUG !== 'undefined') {
  console.log( "Debugging is starting" )
}
```

还有一种不通过`typeof`的安全防范机制，就是检查所有全局变量是否是全局对象的属性，在BOM中是`window`对象，所以，也可以这样检测：

```
if (window.DEBUG) {

}
if (!window.atob) {

}
```

但是这样的检测方法又不适用于需要运行在多种环境中的代码，如果是服务器端代码的话，是不存在`window`对象的。

## 值

### 数组

与强类型语言不同，在JavaScript中，数组可以容纳任何类型的值，可以是字符串、数字、对象甚至是其他数组。对数组进行声明之后，可以立即向其内加入值，不需要预先设定大小。由于数组是对象的子类型，所以可以用键值对来进行赋值，但是这部分赋值不会被加入到原本的数组长度中，如果字符串键可以被强制转换为十进制数字的话，就会被当做数字索引进行处理。

#### 类数组

有时候需要将类数组转换为真正的数组，一般通过数组工具函数来进行实现。有两个地方需要这样转换，一个是DOM查询操作，另外一个是函数的`arguments`参数数组，但是这个已经被ES6废弃了。

*一般用`slice`进行转换，或者ES6的`Array.from`：*

```
function foo() {
  var arr = Array.prototype.slice.call(arguments)
  var arr = Array.from(arguments)
}
```

### 字符串

在很多语言中，字符串和字符数组是相同的意思，但是在JavaScript中，虽然两者有些操作是类似的，但是并不意味着两者相同。

JavaScript中的字符串是不可变的，如果想要获取字符串中的一个字母，使用`b[1]`这种方式不一定合法，正确的方式应该使用`b.charAt(1)`语法。

字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并且返回一个新的字符串，而数组的成员函数都是在其原始值上进行操作的。

并且许多数组方法可以给字符串进行借用，能够借用的都是数组的不可变更成员函数，也就是调用之后不改变原本数组的内容：

```
Array.prototype.join.call(a, '--')
Array.prototype.map.call(a, function(v) {
  return v.toUpperCase()
}).join('')
```

但是可变更成员函数，对于字符串就是不能够借用的了，因为字符串是不可改变的。这时候只能够通过`split`将字符串分解为数组进行处理了。

### 数字

JavaScript只有一种数值类型，number，包括整数和带小数的十进制数。

#### 数字的语法

JavaScript中的数字常量一般用十进制表示。并且前面的0以及小数部分最后的0都可以省略。

也可以用科学计数法来表示数字，基数和指数用`E`隔开：`var a = 5e20`，用`number.toExponential()`可以将普通数字用科学计数法表示。

数字值可以使用Number对象进行封装，因此数字值可以调用Number.prototype的方法。比如使用`toFixed`和`toPrecision`可以分别指定小数部分的显示位数，以及有效数位的显示位数。

数字常量还可以使用二、八、十六进制来表示，这三种表示方法都需要添加前缀，分别是：`0o`、`0b`和`0x`，后面加上相应的数字。

#### 较小的数值

二进制浮点数会出现的最大问题是会出现下面这种情况：

```
0.1 + 0.2 === 0.3  // false
```
造成这种情况的原因主要是二进制浮点数中的0.1和0.2并不是很精确。

为了解决这个问题，需要下面的方法来进行辅助：

```
// 首先针对Number.EPSILON进行Polyfill
if (!Number.EPSILON) {
  Number.EPSILON = Math.pow(2, -52)
}
// Number.EPSILON表示机器精度
function numbersCloseEnoughToEqual(n1, n2) {
  return Math.abs(n1 - n2) < Number.EPSILON
}
```
并且能够呈现的最大浮点数和最小的浮点数都被存放在了`Number.MAX_VALUE`以及`Number.MIN_VALUE`两个常量中了。

并且能够呈现的最大安全整数以及最小安全整数`Number.MAX_SAFE_INTEGER`以及`Number.MIN_SAFE_INTEGER`也都被保存了下来。

#### 整数检测

如果要检测一个值是否为整数，可以使用ES6中的`Number.isInteger`方法。判断一个数字是否是一个安全地整数，可以使用ES6的`Number.isSafeInteger`方法来进行判断。

#### 32位有符号整数

虽然整数最大能够达到53位，但是有些数字操作只能够支持32位，比如数位操作。所以使用`a | 0`可以将变量a中的数值转换为32位有符号整数。

### 特殊数值

JavaScript数据类型中有几个特殊的值需要注意：

#### 不是值的值

`undefined`类型只有一个值，就是它本身，而`null`类型也只有一个值，也是它本身。这两个值常用来表示空值或者不是值的值。两者还是有一些差别的，其中`null`指空值，曾经赋值过，但是目前没有值，而`undefined`表示没有值，也就是从未赋值过。

#### `undefined`

`undefined`在JavaScript中是一个标识符，也就是可以被赋值，全局的`undefined`可以在非严格模式下被赋值，并且局部的`undefined`可以在严格模式下和非严格模式进行赋值，这种操作是*很危险*的。

`void`运算符可以得到`undefined`，这个表达式没有返回值，因此返回的结果是`undefined`，其并不改变表达式的结果，只不过让表达式不返回值。`void 0`就可以获得`undefined`值。

#### 特殊的数字

1. 不是数字的数字：如果数学运算的操作数不是数字类型，或者不能够解析为常规的数字。就无法返回一个有效的数字，这种情况下返回值为NaN。可以理解为无效数值，失败数值或者坏数值等。

`NaN`是一个警戒值，用于指出数字类型中的错误情况，也就是执行数学运算没有成功，是失败之后返回的结果。

并且这个值是非自反的，也就是其和其本身并不相等。`NaN == NaN // false`。

如果需要判断`NaN`，那么可以使用全局函数`window.isNaN()`但是这个函数的判断有些问题，这个函数检查参数是否不是`NaN`，也不是数字：

```
var a = 2 / "foo"
var b = "foo"

window.isNaN(a)  // true
window.isNaN(b)  // true
```

这样会引起一些问题，在ES6加入的`Number.isNaN()`工具函数可以完美解除以上问题。

更简单的办法是这样的：因为`NaN`是JavaScript中唯一的一个非自反的值，可以用这个特性进行判断，如果`a !== a   // 自己不等于自己`，那么就可以判断其是`NaN`了。

2. 无穷数

还有一种计算出错的情况，比如除以0，在JavaScript中，这种情况得到的结果是`Infinity`。计算溢出也可能得到这样的结果。

3. 零值

JavaScript有两个0值，分别为0和-0，-0可以作为常量，也可以作为某些数学运算的结果：`0 / -3  // -0`，并且0和-0用逻辑运算符进行比较是相等的。

#### 特殊等式

之前的描述中，`NaN`和`-0`的有些操作结果是出乎意料的，ES6中加入了新的工具方法`Object.is()`来判断两个值是否绝对相等。

### 值和引用

JavaScript中没有指针操作，所以赋值使用复制或者是引用传递完全依赖赋值对象的类型。

简单值总是通过值复制的方法来进行赋值，包括：null，undefined，字符串，数字，布尔值，符号。

复合值：对象和函数总是通过引用复制的方式来赋值/传递。由于引用指向的是值本身而非变量，所以一个引用无法更改另一个引用的指向。

```
var a = [1,2,3]
var b = a
a;  // [1,2,3]
b;  // [1,2,3]

b = [4,5,6]
a;  // [1,2,3]
b;  // [4,5,6]
```

如果我们给复合值重新赋值一个新的值，那么并不会修改原本的值，只是改变了一个变量的引用。

```
function foo(x) {
  x.push(4)
  x;    // [1,2,3,4]  // 直接改变a的值

  x = [4,5,6] // 切换引用，并不会改变a的值
  x.push(7)
  x;    // [4,5,6,7]
}
var a = [1,2,3]
foo(a)
a;    // [1,2,3,4]
```

## 原生函数

原生函数可以被当做构造函数来用，但是其构造出来的对象可能和设想的不太一样，通过构造函数创建出来的是封装了基本类型值的封装对象。

使用原生函数作为构造函数构造出来的不是基本类型值，而是基本类型值的封装对象。

### 内部属性[[Class]]

所有`typeof`返回值为`object`的对象都包含一个内部属性`[[Class]]`，这个属性可以看做是其在对象内部的分类。这个值一般通过`Object.prototype.toString`进行访问，比如：

```
Object.prototype.toString.call([1,2,3])
// [object Array]
Object.prototype.toString.call(/regex/)
// [object RegExp]
```

对象的内部`[[Class]]`属性和创建该对象的內建原生构造函数相对应。

### 封装对象包装

封装对象扮演着十分重要的角色，由于基本类型值没有`.length`和`.toString()`这样的属性和方法，都需要通过封装对象才能够访问。这时JavaScript会自动为基本类型值包装一个封装对象。

由于JavaScript引擎已经对于调用字面量的方法和属性有过优化了，所以并不需要主动去调用原生函数来封装对象。

使用封装对象可能会出现一些问题，比如`var a = new Boolean(false)`，这样得到的变量`a`不能够用于判断，这个对象代表的是*真值*，如果想要自行封装基本类型值，可以使用`Object()`函数。一般不推荐直接使用封装对象。

### 拆封

如果想要得到封装对象中的基本类型值，可以使用`valueOf()`函数。

### 原生函数作为构造函数

关于数组、对象、函数和正则表达式，一般都以常量的形式进行创建，实际上使用常量和构造函数的效果是一致的，都是会通过封装对象来进行包装的。所以要尽量避免使用构造函数。

比如数组的构造函数，如果传入一个参数，那么会直接构造长度为参数的数组。如果传入多个参数，那么会直接构建一个数组。那么，这样会导致出现一系列的问题，因为其表现差距很大。

所以永远不要使用`Array(3)`这种构建的空单元数组。

#### `Object()`、`Function()`、`RegExp()`

除非万不得已，否则尽量不要使用`Object()`/`Function()`/`RegExp()`。

在实际情况中没有必要使用`new Object()`来创建对象，因为这样就无法像常量形式那样一次设定多个属性，必须逐一设定。

构造函数`Function`只在极少数情况下很有用，比如动态定义函数参数和函数体的时候。

尽量使用常量形式来定义正则表达式，这样语法简单而却执行效率高，但是`RegExp()`函数在需要动态构建正则表达式的时候，也是很有用的。

#### `Date()`和`Error()`

相对于其他原生构造函数，`Date()`和`Error()`的用处要大很多，因为没有对应的常量来作为替代。

创建日期对象必须使用`new Date()`，这个函数可以带参数，用来指定日期和时间，而不带参数的话则使用当前的日期和时间。

ES5中引入了`Date.now()`静态函数，可以直接获取当前的`Unix`时间戳。

构造函数`Error()`带不带关键字都可以。创建错误对象主要是为了获取当前运行栈的上下文。栈上下文信息包括函数调用栈信息和产生错误的代码行号，来便于调试。针对各种错误类型还有一些特定的错误类型的原生构造函数。比如：`RangeError`、`ReferenceError`或者`TypeError`等。

#### `Symbol()`

ES6中新加入了一个基本数据类型-符号。符号是具有唯一特殊性的特殊值，用其来命名对象属性不容易导致重名。

可以用`Symbol()`原生构造函数来自定义符号，但是其比较特殊，不能带`new`关键字，否则会出错。

虽然符号实际上并非私有属性。但符号主要用于私有或者特殊属性。可以用它来代替有下划线前缀的属性，而下划线前缀通常用于命名私有或者特殊属性。

### 原生原型

原生构造函数有自己的`prototype`对象，这些对象包含对应子类型所特有的行为特征。

比如：`String.prototype`包含`fixed()`、`indexOf()`等方法。这些方法可以直接被相应类型的对象所访问。

## 强制类型转换

### 值类型转换

将值从一种类型转换为另外一种类型通常称为类型转换，这是显式的情况；隐式的情况称为强制类型转换。JavaScript中的强制类型转换总是返回标量基本类型值，比如字符串、数字和布尔值。

类型转换发生在静态类型语言的编译阶段，而强制类型转化则发生在动态类型语言的运行时。而在JavaScript中，通常统称为强制类型转换。显示类型转换是很明显的，而隐式类型转换通常是某些操作产生的副作用。比如：

```
var a = 42
var b = a + ""      // 隐式强制类型转换
var c = String( a ) // 显式强制类型转换
```

### 抽象值操作

#### `ToString`

抽象操作`toString`可以进行非字符串到字符串的强制类型转换。对于基本类型值会直接转换为字符串，而对于对象来说，会返回内部属性`[[Class]]`的值。

数组默认的`toString()`方法经过了重新定义，会将所有单元字符串化再用`,`连接起来。

`JSON`字符串化：工具函数`JSON.stringify()`其中也涉及了`ToString`，对于大多数简单值来说，JSON字符串化和`toString()`效果基本相同，只不过序列化的结果总是字符串。

所有的安全JSON值都可以字符串化，不安全的JSON值比如`undefined`、`function`、`symbol`和包含循环引用的对象都不符合JSON结构标准。`JSON.stringify()`在对象中遇到这样的不安全值会自动忽略，而在数组中会返回`null`。

如果对象中定义了`toJSON()`方法，那么JSON字符串化会首先调用该方法，然后用其返回的值来进行序列化。也就是如果需要对非法值的JSON对象进行字符串化，那么需要定义`toJSON()`方法来返回一个安全的JSON值。

可以向`JSON.stringify()`传递一个可选参数replacer，可以使数组或者函数，用来指定对象序列化过程中哪些属性应该被处理，哪些应该被排除。如果`replacer`是一个数组，那么就必须是一个字符串数组，其中包含序列化要处理的对象的属性名称。如果是一个函数，那么其会对对象的每个属性调用一次，如果要忽略某个键就返回`undefined`。字符串化是递归的，所以所有的子元素都会调用一次，包括子元素的子元素等。

`JSON.string`还有一个可选的参数`space`，用来指定输出的缩进格式。`space`为正整数时是指定每一级缩进的字符数，还可以是字符串，此时最前面的十个字符被用于每一级的缩进。

```
JSON.stringify(a, null, "//   ")
/* 
  "{
  //   "c": 3,
  //   "d": "string",
  //   "e": {}
  }"
*/
```

`JSON.stringify`并不是强制类型转换。在这里介绍是因为它涉及`ToString`的强制类型转换。字符串，数字，null，布尔值和`ToString`的规则基本相同。如果传递的对象定义了`toJSON()`方法，那么这个方法会将对象转换为安全的JSON值。

#### `ToNumber`

有时候需要将非数字值当做数字来使用，其中`true`转换为1，`false`转换为0，`undefined`转换为NaN，`null`转换为0.

其对于字符串的处理基本上遵循数字常量的相关语法，处理失败时返回NaN，但是，对于0开头的十六进制数并不能够按十六进制进行处理。为了将值转换为响应的基本类型值，抽象操作`ToPrimitive`会首先检查是否有`valueOf()`方法，如果有并且返回基本类型值，就使用该值进行强制类型转换，否则使用`toString()`的返回值来进行强制类型转换。

#### `ToBoolean`

抽象操作`ToBoolean`可以将变量转换为布尔值，目前的假值有下面几个：

* `undefined`
* `null`
* `false`
* `+0`、`-0`、`NaN`
* `""`

假值对象：也就是封装了假值的对象，这些对象其实转换得到的还是真值。

### 显式强制类型转换

显式类型转换非常清晰，基本上不存在任何争议。

#### 字符串和数字之间的显式类型转换

字符串和数字之前的类型转换是通过`String()`和`Number()`这两个內建函数实现的，分别遵循`ToString`和`ToNumber`规则。

#### `~`运算符

`~`运算符是一个位运算符，这个运算符表示按位取反，而计算机中二进制表示负数的时候，是用*按位取反+1*来进行表示的，也就是：

```
9的原码：00001001
9的补码：11110110
-9    ：11110111
```

那么，直接进行按位取反，就可以得到`-(x+1)`也就是`~x = -(x+1)`，而在`-(x+1)`中能得到0的x值为-1，也就是当x=-1的时候，`~x = 0`，-1是一个哨位值，很多表示执行失败的情况都返回-1，比如JavaScript中的`indexOf()`函数，如果没有找到元素则返回-1。所以当`~indexOf()`值为假的时候，表示操作失败了。

并且这个操作是位操作，并不是数学运算，所以只能够得到0，而不是-0，可以很简单的用于许多操作出现错误的情况。

#### 字位截除

一些开发人员使用`~~`来截除数字值的小数部分，这个运算的第一个`~`执行ToInt32并且反转字位，然后第二个再进行一次字位反转，也就是将所有的字位反转回原值。

这个操作只适用于32位数字，并且其针对于负数的处理和Math.floor不同，会直接去掉负数的小数位，其实`~~`操作无论正负都是直接去掉小数位的。

#### 显式解析数字字符串

解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字。

解析允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止，而转换不允许出现非数字字符，否则会失败，返回`NaN`。

而`parseInt`和`parseFloat`函数接收的都是字符串值，并不能够转换除了字符串之外的值，非字符串参数会首先被强制类型转换为字符串。

`parseInt`的第二个参数可以指定需要转换的进制，如果没有设置这个参数的话，默认进行十进制转换。

#### 显示转换为布尔值

常用的布尔值转换方法是：`!`以及`!!`，分别返回当前值的假值以及当前值。在`if()`这样的上下文中，如果没有使用显式的类型转换，也会自动进行隐式的类型转换。

### 抽象关系比较

如果比较双方都是字符串，则按字母顺序来进行比较。

针对关系比较运算符：`>`、`<`、`<=`、`>=`。逻辑比较运算符是不能够避免强制类型转换。

为了保证安全，只能够使用显式强制类型转换。

## 语法

### 语句的结果值

所有的语句都有一个结果值，获得结果值最直接的方法是在浏览器开发控制台中输入语句，默认情况下控制台会显示所执行的最后一条语句的结果值。

#### 语句的返回值

`delete`运算符可以用来删除对象中的属性和数组中的单元。如果操作成功，`delete`返回`true`，否则返回`false`。其副作用是属性被从对象中删除。

针对赋值运算符，`a = 42`中的赋值运算符看起来没有副作用，实际上得到的结果是42，而副作用是进行赋值，所以赋值运算可以链式调用。

### 运算符优先级

#### 短路

针对于`&&`以及`||`运算符，如果从左边的操作数能够得到结果，就可以忽略右边的操作数，这种现象称为短路。

也就是如果`&&`的左操作数为真值，或者`||`的左操作数为假值，就会直接返回左边的值，否则返回右边的值。

#### 更强的绑定

针对逻辑与、逻辑或以及三目运算符来说，有下面的这个例子：

`a && b || c ? c || b ? a : c && b : a`，其执行顺序为：

`(a && b || c) ? (c || b) ? a : (c && b) : a`，也就是优先级为：
`&& > || > ? :`。

#### 关联

一般来说，运算符的关联不是从左到右就是从右到左的，这取决于组合的方向。组合和执行顺序不同：

`a && b && c`这个表达式的执行顺序一直是从左到右的，其也是左关联的，也就是它的组合方式是：`(a && b) && c`。

一般的运算符都是左关联的，只有三目运算符和赋值运算符两个是右关联的，所以赋值运算符才能够实现链式调用。

### 自动分号

有时候JavaScript会自动为代码补上缺失的分号。

### try..finally

针对于含有`finally`语句的函数来说，如果在`try`语句块中直接进行`return`，那么除了`finally`语句块中的代码之外，后面的其余函数代码都不会执行：

```
function foo() {
  try {
    return 12
  } finally {
    console.log("Hello")
  }
  // 下面的代码永远不会被执行
  console.log("never runs")
}
console.log(foo())
// Hello
// 12
```