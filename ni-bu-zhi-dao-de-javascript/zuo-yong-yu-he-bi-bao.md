## 作用域

LHS: 赋值操作的左侧，也就是赋值操作的目标。

RHS：赋值操作的右侧，也就是赋值操作的源头。

### 异常W

在变量还没有进行声明，也就是在作用域链上的所有作用域中都无法找到这个变量的时候，LHS和RHS的查询行为是不一样的。

在严格模式下：由于不允许隐式声明变量，所以这两种操作都会抛出一个`ReferenceError`。

在普通模式下：对于LHS，作用域会创建一个同名的变量，并且将其挂载全局作用域中，而对于RHS，则会返回`ReferenceError`。

如果对于能够找到的变量，进行错误的操作方法，会抛出`TypeError`。

`ReferenceError`_同作用域判别失败相关，而_`TypeError`_则代表作用域判别成功了，但是对结果的操作是非法或不合理的。_

## 词法作用域

### 词法作用域与动态作用域

词法作用域是一段代码或者是一个函数，也就是以一段静态的范围作为一个变量的作用域。  
动态作用域是只要正在执行定义了变量的代码段，那么这个变量就一直存在。

在编译器编译代码的第一个工作阶段就叫做词法化，词法作用域就是定义在词法阶段的作用域，也就是由写代码的时候将变量写在哪里来确定的。  
无论函数是在哪里被调用的，也无论函数如何被调用，函数的词法作用域都只由函数被声明时所处的位置决定的。并且词法只会试图查找一级标识符，并且返回，如果需要一级下面的二级或者三级的内容，就需要自己进行获取了。

### 欺骗词法作用域

#### `eval`

这个函数会将一个字符串当做代码直接进行执行，如果这个字符串里面传入了一些变量的定义，就会导致词法作用域发生了修改，可能导致代码的执行结果不尽相同。  
_在严格模式中，_`eval`_拥有其自己的词法作用域，也就是不会污染原本的词法作用域_。

#### `with`

相当于将下面的代码段切换到了参数所组成的那个词法作用域中。

```
foo = function (obj) {
    with(obj) {
        a = 2;
    }
}
var o1 = {
    a: 3
}
foo(o1)
o1.a = 2
```

但是，如果传入的参数不存在LHS的话，那么就会导致在全局作用域上新建一个对应的变量。  
由于引擎对于代码的优化是基于了解完整的静态代码的，所以对于产生不可知代码的`eval`以及`with`是不进行优化的，甚至让很多已经优化完成的地方都没有效果，所以会在很大程度上影响代码的运行效率，_不要使用这两个运算符_。

## 函数作用域和块作用域

函数作用域：就是这个函数的全部变量都可以在整个函数的范围内使用和复用。  
最小特权原则：在软件设计中，应该最小限度地暴露必要内容，而将其他内容都隐藏起来。就是仅仅暴露API，但却将API的内部封装起来。

### 匿名函数和具名函数

匿名函数可以很好地防止全局或者某些局部作用域被污染。但是完全匿名的函数表达式会有一些问题，比如在进行栈追踪的时候不会显示任何函数名信息，难以调试，或者在调用自身的时候比较麻烦。  
所以最好使用行内函数表达式，也就是具名的行内函数。

```
setTimeout(function timeoutHandle() {
    console.log("I waited 1 second!")
}, 1000)
```

这种方法集合了两者的优点。  
IIFE：立即执行函数表达式\(Immediately Invoked Function Expression\)

### 块作用域

下面几个关键字都是能声明一个块作用域的：

#### `with`

这个关键字可以创建一个块级作用域，这个作用域只在`with`声明的内部有效。

#### `try/catch`

`catch`分句会创建一个块级作用域，在这个作用域里面声明的变量仅仅在`catch`内部有效。

#### `let`

1. 垃圾收集：在当有些数据需要在使用后立即释放的时候，可以显式声明一个块级作用域，并且在里面使用`let`来声明需要使用完释放变量，这样可以做到准确的垃圾回收。

2. `let`循环：在`for`循环中使用let来进行循环变量的声明，可以保证每次迭代的时候，都会声明并且绑定一个新的循环变量。

## 提升

编译器在对JavaScript代码进行编译的时候是这样的：

```
console.log(a);
var a = 2;
// 上面的这段代码实际上的执行顺序是下面这样的：
var a;
console.log(a);
a = 2;
```

因为编译器在对代码进行编译的时候，首先会遍历代码中的所有变量声明，然后对这些变量全部声明，并且将其放在指定的作用域当中。所以变量声明会被提升至作用域的顶端。  
而针对于函数来说，函数的声明会被提升，但是函数的表达式不会被提升，也就是：

```
// 这样会被提升，也就是直接声明函数，这个函数会被提升到顶部
function foo() {
    ...something()
}
// 这样bar不会被提升，仅有foo的变量声明被提升了
var foo = function bar() {
    ...somethingElse()
}
```

### 函数优先

函数和变量的声明都会提升，而首先被提升的应该是函数而不是变量。也就是函数声明会被提升到变量声明之前。

## 闭包\(closure\)

当函数可以记住并且访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行的。

```
function foo() {
    var a = 2;
    function bar() {
        console.log(a)
    }
    return bar
}
var baz = foo(); // 这个baz函数其实就是返回的bar函数，是bar函数在词法作用域之外执行的情况
```

由于bar函数被作为返回值返回了，所以其保有的foo函数的作用域不能够被销毁，可以在之后的任何时间进行引用。bar依然保有对这个作用域的引用，称为闭包。  
无论通过何种手段将内部函数传递到所在的词法作用域之外，这个函数都会保持着原来定义时候的作用域，无论这个函数在哪里调用，都会使用到原来的闭包。

### 模块

构建一个函数，并且由这个函数来返回一个对象，这个对象的方法或者属性都拥有着函数内部的词法作用域，形成了模块化的封装。

```
function Foo() {
    let a;
    let b;
    doSomething() {}
    doAnotherthing() {}
    return {
        doSomething,
        doAnotherthing
    }
}
var foo = foo()
```

这种情况是可以进行多次函数调用来获取多个模块实例的，如果只需要一个模块实例的话，可以使用IIFE来生成模块。

### ES6模块机制和ES5模块机制

ES5的模块机制是通过函数来实现的，但是函数实现的模块可以再运行的时候被修改，ES6中模块的API是通过export来实现的，所以API不会再运行的时候改变，并且在模块导入的时候会进行检测，检测API是否存在。  
ES6中一个独立地文件代表一个模块。并没有行内模式。

