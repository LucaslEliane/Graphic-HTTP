## React Reconciliation

React提供了一个声明的API来在修改之后进行自动更新。

### Motivation

当使用React的时候，`render()`函数创建了一个React elements的树。当下一个state或者是props更新了之后，`render()`函数会返回一个不同的React元素树，这时候需要高效地返回一个匹配最近的elements树的UI出来。

React使用了一个启发式算法来实现O(n)复杂度的树的更新方法，这个方法基于两个假设：

1. 两个不同类型的element会产生不同的树。
2. 开发人员可以通过不同的`key`属性来暗示哪些子元素在不同的渲染中是稳定的。

### The Diffing Algorithm

当进行两个树的比较的时候，React首先比较两个根元素，取决于根元素的类型不同，diff的行为也不同。

#### 不同类型的elements

无论何时，只要根元素有着不同的类型，React都会将旧树拆下，并且构建一棵新的树，旧的树和新的树都会完成其生命周期，包括旧树的`componentWillUnmount()`以及新树的`componentWillMount()`和`componentDidMount()`。旧树上的所有状态都会丢失。旧树的所有子组件也都会被卸载并且摧毁。

#### 相同类型的DOM元素

当两个React DOM elements有着相同的类型的时候，React会查看两者的属性，保留相同的属性，对于不同的属性进行更新。

#### 相同类型的组件元素

当一个组件更新的时候，实例保持不变，所以状态通过render进行保持，React更新旧的组件实例来匹配新的元素，并且调用其`componentWillReceiveProps()`方法来进行组件更新。

`render()`方法会被调用，并且在新的渲染结果和旧的结果之间调用diff算法。

#### 循环子元素

默认情况下，对于循环产生的DOM子元素，React同时遍历两个子元素列表，来为不同的地方产生一个突变。当在列表最后添加一个元素的时候可以正常运行，但是在往第一个添加元素的时候就效率很低了。

#### keys

为了解决上面的问题，React支持`key`属性，这个属性是针对循环添加的元素的，React使用这个值来匹配原始树上的子元素，React就知道那个元素是可以重用的，而哪些需要移动。这个值需要在兄弟元素中唯一，但是并不需要全局唯一。